//NOTE: This software runs with several NetBeans packages and doesn't necessrily compile on its own. 
//For observation only.
//Dan Pengra and Tyler Jensen
//CSC 487- Project 1
//Vigenere Encryption Suite
//Purpose: This tool takes the grunt work out of Vigenere decryption by posing some
//common functions needed for the job.
//Statement:
//Dan Pengra and Tyler Jensen are responsible for creating this sourcecode.
//No online sources, excluding GUI software tools, were used.
//All the required functions were coded originally by us.

/*
 * //NOTE: The important part of the sourcecode starts at line 196 and ends at line 570.
 */
package encryptor;
import static java.lang.Integer.parseInt;
import java.util.Arrays;

/**
 *
 * @author danpengra
 */

public class Menu extends javax.swing.JFrame {
    public static char[] letters=new char[26]; 
    public static int[] thing = new int[26];
    /**
     * Creates new form Menu
     */
    public Menu() {
        initComponents();
        
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        jComboBox1 = new javax.swing.JComboBox<>();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jTextField1 = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Caesar", "Vigenere", "Index of Coincidence", "Columnate", "Catch Phrases", "Rows = Columns", "Column Analysis" }));

        jTextArea1.setColumns(20);
        jTextArea1.setFont(new java.awt.Font("Courier New", 0, 13)); // NOI18N
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        jTextArea2.setColumns(20);
        jTextArea2.setFont(new java.awt.Font("Courier New", 0, 13)); // NOI18N
        jTextArea2.setRows(5);
        jScrollPane2.setViewportView(jTextArea2);

        jTextField1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField1ActionPerformed(evt);
            }
        });

        jLabel1.setText("Method");

        jLabel2.setText("Key/Shift By");

        jButton1.setText("Encrypt");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton2.setText("Decrypt");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(jLabel2)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                            .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 135, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(jButton1)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jButton2)))
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 328, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 437, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 289, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(73, 73, 73)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1))
                .addGap(21, 21, 21)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel2)
                    .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jButton1)
                    .addComponent(jButton2))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addGap(18, 18, 18)
                .addComponent(jScrollPane2)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>                        

    private void jTextField1ActionPerformed(java.awt.event.ActionEvent evt) {                                            
        // TODO add your handling code here:
    }                                           

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {                                         
if(jComboBox1.getSelectedIndex()==0){
    assignLetters();        
    caesarCode();
            
        }
else if(jComboBox1.getSelectedIndex()==1){
    assignLetters();
    vigCipher();
}
else if (jComboBox1.getSelectedIndex()==2){
        idxOfCoincidence();
        }
else if (jComboBox1.getSelectedIndex()==3){
        columnate();
}
else if (jComboBox1.getSelectedIndex()==4){
       simPhrase();
}
else if (jComboBox1.getSelectedIndex()==5){
       columnSwap();
}
else if (jComboBox1.getSelectedIndex()==6){
       colPrint(jTextArea1.getText(), parseInt(jTextField1.getText()));
}
    }                                        

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {                                         
        if(jComboBox1.getSelectedIndex()==0){
    assignLetters();        
    caesarCodeR();
            
        }
        else if(jComboBox1.getSelectedIndex()==1){
    assignLetters();
    vigCipherR();
}
        else if (jComboBox1.getSelectedIndex()==2){
        idxOfCoincidence();
        }
        else if (jComboBox1.getSelectedIndex()==3){
        columnate();
}
        else if (jComboBox1.getSelectedIndex()==4){
        simPhrase();
}
        else if (jComboBox1.getSelectedIndex()==5){
       columnSwap();
}
        else if (jComboBox1.getSelectedIndex()==6){
       colPrint(jTextArea1.getText(), parseInt(jTextField1.getText()));
}
        
    }                                        

  //**************************************  
  //Function Name: caesarCode 
  //Purpose: Caesar encryption
  //**************************************
  private void caesarCode(){
        String plaintext=jTextArea1.getText();
         plaintext = plaintext.toUpperCase();					//Convert all to uppercase
        char[] cipher = plaintext.toCharArray();
        int shiftNum = parseInt(jTextField1.getText());      
        for(int y=0; y<plaintext.length(); y=y+1){
            if(Character.isLetter(cipher[y])){					
            cipher[y]=letters[((int)cipher[y]-65+shiftNum)%26];  //This shifts the ASCII value by the user's input number.
            }	
            jTextArea2.setText(new String(cipher));
        }
        
    }
  //**************************************  
  //Function Name: vigCipher
  //Purpose: Vigenere encryption
  //**************************************
    private void vigCipher(){
    
     String plaintext=jTextArea1.getText();
         plaintext = plaintext.toUpperCase();
        char[] cipher = plaintext.toCharArray();
        String slaintext =  jTextField1.getText();
        slaintext = slaintext.toUpperCase();
        char[] key =slaintext.toCharArray();
       int shiftNum = 0;
       int letNum = 0;
        for(int y=0; y<plaintext.length(); y=y+1){
            shiftNum = ((int)key[letNum % slaintext.length()]-65);
            if(Character.isLetter(cipher[y])){
            cipher[y]=letters[((int)cipher[y]-65+shiftNum)%26];	//For readabiity I used a character array for each letter of the alphabet.
            letNum++;											//This loop shifts each character using modulo to repeat the key throughout the cipher.
            }
            jTextArea2.setText(new String(cipher));
        }
        
    }
//**************************************  
  //Function Name: colPrint
  //Purpose: This counts letter frequency through 
  //a given number of columns and analyzes potential
  //Vigenere keys using two functions.
  //It is also responsible for printing the result.
  //**************************************
    private void colPrint(String input, int colLen){
        String[] column = new String[colLen];
        String finalStr="";
        for(int r=0; r<colLen; r++){
              column[r]="";
        }
        for(int r=0; r<input.length(); r++){//Separating text into columns
            column[r%colLen]=column[r%colLen]+input.charAt(r);
        }
        for(int e=0; e<colLen; e++){//Print heading
            finalStr=finalStr+"COLUMN "+e+":\n\n"+lettCount(column[e])+'\n';
        }
        finalStr=finalStr+"\n\nPotential key:\n";//Print a guess at the key
        for(int e=0; e<colLen; e++){
            lettCount(column[e]);
            finalStr=finalStr+stringAnalysis(column[e]);
        }
        jTextArea2.setText(finalStr);
    }
	  //**************************************  
  //Function Name: lettCount
  //Purpose: Returns a string that contains
  //the letter frequency inside a passed
  //in string.
  //**************************************
    private String lettCount(String input){
        input=input.toLowerCase();
        String output="";
           for(int w=0; w<26; w++){
               thing[w]=0;
            } 
        for(int a=0; a<input.length(); a=a+1){
                if(Character.isLetter(input.charAt(a))){
                    thing[input.charAt(a)-97]++;
                }//This increments an integer array in the class scope for instances of letters
            }
            for(int w=0; w<26; w++){
                output = output + "    " + (char)(w+65) + "="+thing[w];
                if(w%5==4){
                output = output+'\n';
                }//This prints the results
            }
    return output;
    }  
	//**************************************  
  //Function Name: caesarCodeR
  //Purpose:Caesar decryption
  //**************************************
    private void caesarCodeR(){
    String plaintext=jTextArea1.getText();
         plaintext = plaintext.toUpperCase();
        char[] cipher = plaintext.toCharArray();
        int shiftNum = parseInt(jTextField1.getText());
        //String cipher = plaintext;
       
        for(int y=0; y<plaintext.length(); y=y+1){
            if(Character.isLetter(cipher[y])){
            cipher[y]=letters[modRework(((int)cipher[y]-65-shiftNum)%26, 26)];
            }
            jTextArea2.setText(new String(cipher));
        }
    }
    	//**************************************  
  //Function Name: caesarCodeR
  //Purpose:Vigenere decryption
  //**************************************
    private void vigCipherR(){
    String plaintext=jTextArea1.getText();
         plaintext = plaintext.toUpperCase();
        char[] cipher = plaintext.toCharArray();
        String slaintext =  jTextField1.getText();
        slaintext = slaintext.toUpperCase();
        char[] key =slaintext.toCharArray();
       int shiftNum = 0;
       int letNum = 0;
        for(int y=0; y<plaintext.length(); y=y+1){
            shiftNum = ((int)key[letNum % slaintext.length()]-65);
            if(Character.isLetter(cipher[y])){
            cipher[y]=letters[modRework(((int)cipher[y]-65-shiftNum)%26,26)];
            letNum++;
            }
            jTextArea2.setText(new String(cipher));
        }
    }
  //**************************************  
  //Function Name: modRework
  //Purpose:This is just here to prevent a segfault 
  //where you're searching for x[-1], by adding the 
  //divisor to a modulo calculation.
  //**************************************
    private int modRework(int tester, int modNum){
    if(tester>=0){
        return tester;
    }
    else{
        return modNum+tester;
    }
        
    }
	  //**************************************  
  //Function Name: idxOfCoincidence
  //Purpose: 
  //**************************************
    private void idxOfCoincidence(){
    int totals[]= new int[26];
    int numerator = 0;
    int denom = 0;
    char text[] = jTextArea1.getText().toUpperCase().toCharArray();
    for(int q=0; q<26; q=q+1){
        for(int r=0; r<jTextArea1.getText().length(); r=r+1){
            if(text[r]==(q+65)){
                totals[q]++;//Determining quantity of letters
            }
            
            
        }
    }
    for(int w=0; w<26; w=w+1){
      numerator=numerator+(totals[w]*(totals[w]-1));  
    }//Determining the numerator
    for(int r=0; r<jTextArea1.getText().length(); r=r+1){
            if(Character.isLetter(text[r])){
            denom++;
            }//Calculates the string length(specifically only letters)
        }
    String total = Integer.toString(numerator);
    
    
    
    total = total+"/"+(Integer.toString((denom)*(denom-1)));
    jTextArea2.setText(total);//Print the message
    }
//**************************************  
  //Function Name: stringAnalysis
  //Purpose:This function tries to determine the 
  //best letter for each column in the key 
  //It takes the column input as a string and 
  //uses some already-calculated data from 
  //the letter frequency function.
  //Each letter in the alphabet is divided into 
  //one of three categories: common, moderate, and rare.
  //The algorithm checks if each letter quantity is 
  //proportional to its expected amount, and 
  //increments a rating integer for each accurate 
  //figure. The process repeats 26 times, shifting the 
  //alphabet once each time. The highest rating 
  //is returned as a character.
  //**************************************
    
    private char stringAnalysis(String lett){
        char[] letterAlph=new char[26];//alphabet array for readability
        for(int a=0; a<26; a++){
            letterAlph[a]=(char)(a+97);
        }
        int currentRating=0;//Rating going through the loop
        int bestRating=0;//Best rating so far
        char topRateChar='0';//Character to go with that rating
    //String lett = jTextArea1.getText();
    for(int w=0; w<26; w++){
        currentRating=0;
	for(int v=0; v<26; v++){
            if(letterAlph[v]=='z' || letterAlph[v]=='j' || letterAlph[v]=='x' || letterAlph[v]=='q' || letterAlph[v]=='k' || letterAlph[v]=='v' || letterAlph[v]=='g'|| letterAlph[v]=='p'|| letterAlph[v]=='b'){
			if(thing[(((v-w)%26)+26)%26]<=(roundUp(lett.length(),50))){//Rare letters usually occur 2% of the time 
                            currentRating++;
                        }	
			}
            else if(letterAlph[v]=='h' || letterAlph[v]=='r' || letterAlph[v]=='d' || letterAlph[v]=='l' || letterAlph[v]=='u' || letterAlph[v]=='c' || letterAlph[v]=='m'|| letterAlph[v]=='f'|| letterAlph[v]=='w'|| letterAlph[v]=='y'){
			if(thing[(((v-w)%26)+26)%26]<=(roundUp(lett.length(),17))){//Mid-range letters occur 2-6% of the time
                            currentRating++;
                        }
			}
            else if(letterAlph[v]=='a' || letterAlph[v]=='e' || letterAlph[v]=='t' || letterAlph[v]=='i' || letterAlph[v]=='n' || letterAlph[v]=='o' || letterAlph[v]=='s'){
			if(thing[(((v-w)%26)+26)%26]>=(roundUp(lett.length(),17))){//Anything above 6% is common
                            currentRating++;
                        }
			}
		
	}
        if(currentRating>bestRating){//update rating if it was higher
            bestRating=currentRating;
            topRateChar=(char)(w+65);
        }
}
      
    
    return topRateChar;
    }
   //**************************************  
  //Function Name: roundUp
  //Purpose: Division that rounds up
  //**************************************   
    public static int roundUp(int num, int divisor) {
    return (num + divisor - 1) / divisor;
}
  //**************************************  
  //Function Name: columnate
  //Purpose: Separates a paragraph into a 
 // given number of columns
  //**************************************
     private void columnate(){
     String original;
     String convert = "";
     int colNum= parseInt(jTextField1.getText())+1;
     int letSequ=0;
     original = jTextArea1.getText();
     original = original.toUpperCase();
     
     for(int z=0; z<original.length(); z=z+1 ){
         if(letSequ%colNum==colNum-1){
             convert = convert + '\n';
             letSequ++;  
         }
         if(Character.isLetter(original.charAt(z))){
            convert = convert +  original.charAt(z);   
            letSequ++;
         }
     }
     jTextArea2.setText(convert);
     }
    
      //**************************************  
  //Function Name: assignLetters
  //Purpose: Assigns a 26 character array with the letters of the alphabet.
  //**************************************
    
    private void assignLetters(){
        for(int e=0; e<26; e=e+1){
        letters[e]=(char)(65+e);
       
        }
    }
//**************************************  
  //Function Name: simPhrase
  //Purpose: Detects common patters in 2-3 
  //word phrases in a piece of ciphertext,
  //their spacing, location, and multiples
  //of the spacing from 1 to 10.
  //**************************************
    private void simPhrase(){
    String collect = jTextArea1.getText();
    String locations;//These three output strings are combined after they move through the string once.
    String divisors="\t";
    String results = "";
    results=results+"Phrase\tSpacing\tLocations\tDivisors\n";
    Boolean hitflag=false;//Activates when a phrase match is found
    for(int c=0; c<collect.length(); c=c+1){
        hitflag=false;
        locations="\t"+c;
         divisors="\t";
        for(int d=c+1; d<collect.length()-3; d=d+1){
            
            if(collect.substring(c, c+3) == null ? collect.substring(d, d+3) == null : collect.substring(c, c+3).equals(collect.substring(d, d+3))){
                
                if(!results.contains(collect.substring(c,c+3))){
                        results=results+collect.substring(c, c+3)+'\t';//Prints phrase
                hitflag=true;}
                
                if(collect.indexOf(collect.substring(c,c+3))==c && hitflag){
                        results=results+' '+Integer.toString(d-c);//Prints spacing
                        for(int h=2; h<11; h=h+1){
                            if((d-c)%h==0&& !divisors.contains(Integer.toString(h))){
                                divisors=divisors+Integer.toString(h)+' ';//Prints divisors
                            }
                        }
                        locations=locations+' '+Integer.toString(d);//Prints locations
                }
                
            }
        }
        if(hitflag){
        results=results+locations+divisors+"\n";}
    }
    
    for(int c=0; c<collect.length(); c=c+1){//This repeats the processes in the last for loop with 2-letter phrases
        hitflag=false;
        locations="\t"+c;
        divisors="\t";
        for(int d=c+1; d<collect.length()-2; d=d+1){
            if(collect.substring(c, c+2) == null ? collect.substring(d, d+2) == null : collect.substring(c, c+2).equals(collect.substring(d, d+2))){
               if(!results.contains(collect.substring(c,c+2))){
                        results=results+collect.substring(c, c+2)+'\t';
               hitflag=true;}
               if(collect.indexOf(collect.substring(c,c+2))==c && hitflag){
                        results=results+' '+Integer.toString(d-c);
                        for(int h=2; h<11; h=h+1){
                            if((d-c)%h==0 && !divisors.contains(Integer.toString(h))){
                                divisors=divisors+Integer.toString(h)+' ';
                            }
                        }
               locations=locations+' '+Integer.toString(d);}
              
               //results=results+collect.substring(c, c+2)+Integer.toString(d-c);
                
               }
        }
         if(hitflag){
        results=results+locations+divisors+"\n";}
    }
    int placeMark=0;
    String realResults="";
   // for(int b=0; b<results.length(); b=b+1){
        
    //}
    
    jTextArea2.setText(results);
    }
	  //**************************************  
  //Function Name: columnSwap
  //Purpose: Shifts rows with columns
  //**************************************
    private void columnSwap(){
        String original = jTextArea1.getText();
        String swapped = "";
        int colCheck = parseInt(jTextField1.getText());
        //int colCheck = original.indexOf('\n');
        
        
        
        for(int g=0; g<colCheck; g=g+1){//For loop through each column
            for(int h=0; h<original.length(); h=h+1){//For loop for each character
                if(h%colCheck==g && original.charAt(h)!='\n'){
                    swapped=swapped+original.charAt(h);
                }
            }
            swapped=swapped+'\n';
        }
        jTextArea2.setText(swapped);
    }
   
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Menu.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Menu.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Menu.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Menu.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Menu().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify                     
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JComboBox<String> jComboBox1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextArea2;
    private javax.swing.JTextField jTextField1;
    // End of variables declaration                   
}
